# 第二章 第一讲  VIM和GCC

## VIM

### 基础介绍


Vim是从vi发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和Emacs并列成为类Unix系统用户最喜欢的编辑器。

----

**vi**

vi是“Visual”的不正规的缩写，来源于另外一个文本编辑器ex的命令visual。

vi是一种模式编辑器。不同的按钮和键击可以更改不同的“模式”。在“插入模式”下，输入的文本会直接被插入到文档；当按下“退出键”，“插入模式”就会更改为“命令模式”，并且光标的移动和功能的编辑都由字母来响应，例如：“j”用来移动光标到下一行；“k”用来移动光标到上一行，“x”可以删除当前光标处的字符，“i”可以返回到“插入模式”（也可以使用方向键）。在“命令模式”下，敲入的键（字母）并不会插入到文档，这给新接触vi的用户带来混乱。

在“命令模式”下，多重文本编辑操作是由一组键（字母）来执行，而不是同时按下<Alt>、<Ctrl>和其他特殊键来完成。更多复杂的编辑操作可以使用多重功能基元的组合，比如说“dw”用来删除一个单词，“c2fa”可以更改当前的光标处中“a”之前的文本。这就是说：对于熟练的vi用户可以更快的操作，因为双手就可以不必离开键盘。

早期的版本中，vi并没有指示出当前的模式，用户必须按下“退出键”来确认编辑器返回“命令模式”（会有声音提示）。当前的vi版本可以在“状态条”中（或用图形显示）。最新的版本中，用户可以在“终端”中设置并使用除主键盘以外的其他键，例如：PgUp，PgDn，Home，End和Del键。图形化界面的vi（如gvim）可以很好的支持鼠标和菜单。

直到Emacs的出现（1984年以后），vi几乎是所有“黑客”所使用的标准UNIX编辑器。从2006年开始，作为“单一UNIX规范”（Single UNIX Specification）的一部分，vi或vi的一种变形版本一定会在UNIX中找到。

直到现在，vi仍然被广泛的使用，并且赢得1991年在USENET的票选；vi比Emacs的Bulkier版本启动的更快，并且占内存更少。因此，甚至Emacs的追随者又重新使用vi，并且作为邮件编辑器和其他小型编辑工作的首选。1999年时，著名的欧莱礼出版社（O'reilly）卖出了比emacs更多的vi参考书。

当救急软盘作为恢复硬盘崩溃的介质以来，vi通常被用户选择，因为一张软盘正好存储下vi，并且几乎所有人都可以很轻松的使用vi。

在编辑器的大战中，vi和Emacs是作战的双方。

----

Vim的第一个版本由布莱姆·米勒在1991年发布。最初的简称是Vi IMitation，随着功能的不断增加，正式名称改成了Vi IMproved。现在是在开放源代码方式下发行的自由软件。

布莱姆·米勒在80年代末购入他的Amiga计算机时，Amiga上还没有他最常用的编辑器vi。Bram从一个开源的vi复制Stevie开始，开发了Vim的1.0版本。最初的目标只是完全复制vi的功能，那个时候的Vim是Vi IMitation（模拟）的简称。1991年Vim 1.14版被"Fred Fish Disk #591"这个Amiga用的免费软件集所收录了。1992年1.22版本的Vim被移植到了UNIX和MS-DOS上。从那个时候开始，Vim的全名就变成Vi IMproved（改良）了。

在这之后，Vim加入了不计其数的新功能。做为第一个里程碑的是1994年的3.0版本加入了多窗口编辑（分割视窗）模式，可以在同一终端中同时编辑多个文件。1996年发布的Vim 4.0是第一个利用GUI（图形用户界面）的版本。1998年5.0版本的Vim加入了highlight（语法高亮）功能。2001年的Vim 6.0版本加入了代码折叠、插件、多国语言支持、垂直分割视窗等功能。2006 年5月发布的Vim 7.0版更加入了拼字检查、上下文相关补全，标签页编辑等新功能。2008年8月发布的Vim 7.2，合并了Vim 7.1以来的所有修正补丁，并且加入了脚本的浮点数支持。

目前，VIM是按照VIM许可证发布的开源软件，这个协议兼容GPL。它的协议中包含一些慈善条款，建议用户向荷兰ICCF捐款，用于帮助乌干达的艾滋病患者。VIM启动时会显示「Help poor children in Uganda!」的字样，在中文版本中则是「请帮助乌干达的可怜孩童!」。


对于大多数用户来说，Vim有着一个比较陡峭的学习曲线。这意味着开始学习的时候可能会进展缓慢，但是一旦掌握一些基本操作之后，能大幅度提高编辑效率。为了帮助学习，Vim为初学者准备了Vim教学。通常可以在Unix系统命令行下输入"vimtutor"或者点击Windows系统桌面上的Vim教学图标进入。在Vim用户手册中更加详细的描述了Vim的基础和进阶功能。可以在Vim中输入":help user-manual"进入用户手册。手册除了原始的英文版本之外，也被志愿者翻译成了各国文字，其中包括中文。

新用户也应该学习Vim的帮助系统。可以在Vim中输入不带参数的"help"来阅读主帮助文件。

### 用法

普通模式
在普通模式中，用的编辑器命令，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。这正好和许多新用户期待的操作方式相反（大多数编辑器默认模式为插入模式）。

Vim强大的编辑能力来自于其普通模式命令。普通模式命令往往需要一个操作符结尾。例如普通模式命令"dd"删除当前行，但是第一个"d"的后面可以跟另外的移动命令来代替第二个"d"，比如用移动到下一行的"j"键就可以删除当前行和下一行。另外还可以指定命令重复次数，"2dd"（重复"dd"两次），和"dj"的效果是一样的。用户学习了各种各样的文本间移动／跳转的命令和其他的普通模式的编辑命令，并且能够灵活组合使用的话，能够比那些没有模式的编辑器更加高效的进行文本编辑。

在普通模式中，有很多方法可以进入插入模式。比较普通的方式是按"a"（append／追加）键或者"i"（insert／插入）键。

插入模式
在这个模式中，大多数按键都会向文本缓冲区中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。

在插入模式中，可以按ESC键回到普通模式。

可视模式
这个模式与普通模式比较相似。但是移动命令会扩大高亮的文本区域。高亮区域可以是字符、行或者是一块文本。当执行一个非移动命令时，命令会被执行到这块高亮的区域上。Vim的"文本对象"也能和移动命令一样用在这个模式中。

选择模式
这个模式和无模式编辑器的行为比较相似（Windows标准文本控件的方式）。这个模式中，可以用鼠标或者光标键高亮选择文本，不过输入任何字符的话，Vim会用这个字符替换选择的高亮文本块，并且自动进入插入模式。

命令行模式
在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（":"键），搜索（"/"和"?"键）或者过滤命令（"!"键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。

Ex模式
这和命令行模式比较相似，在使用":visual"命令离开Ex模式前，可以一次执行多条命令。


操作符等待模式
这个派生模式指普通模式中，执行一个操作命令后Vim等待一个"动作"来完成这个命令。Vim也支持在操作符等待模式中使用"文本对象"作为动作，包括"aw"一个单词（a word）、"as"一个句子（a sentence）、"ap"一个段落（a paragraph）等等。

比如，在普通模式下"d2as"删除当前和下一个句子。在可视模式下"apU"把当前段落所有字母大写。

插入普通模式
这个模式是在插入模式下按下ctrl-o键的时候进入。这个时候暂时进入普通模式，执行完一个命令之后，Vim返回插入模式

插入可视模式
这个模式是在插入模式下按下ctrl-o键并且开始一个可视选择的时候开始。在可视区域选择取消的时候，Vim返回插入模式。

插入选择模式
通常这个模式由插入模式下鼠标拖拽或者shift方向键来进入。当选择区域取消的时候，Vim返回插入模式。

替换模式
这是一个特殊的插入模式，在这个模式中可以做和插入模式一样的操作，但是每个输入的字符都会覆盖文本缓冲中已经存在的字符。在普通模式下按"R"键进入。


Evim（Easy Vim）是一个特殊的GUI模式用来尽量的表现的和"无模式"编辑器一样。编辑器自动进入并且停留在插入模式，用户只能通过菜单、鼠标和键盘控制键来对文本进行操作。可以在命令行下输入"evim"或者"vim -y"进入。在Windows下，通常也可以点击桌面上Evim（Easy Vim）的图标。


## GCC


### 基础介绍

GNU编译器套装（英语：GNU Compiler Collection，缩写为GCC），指一套编程语言编译器，以GPL及LGPL许可证所发行的自由软件，也是GNU计划的关键部分，也是GNU工具链的主要组成部分之一。GCC（特别是其中的C语言编译器）也常被认为是跨平台编译器的事实标准。1985年由理查德·马修·斯托曼开始发展，现在由自由软件基金会负责维护工作。

原名为GNU C语言编译器（GNU C Compiler），因为它原本只能处理C语言。GCC在发布后很快地得到扩展，变得可处理C++。之后也变得可处理Fortran、Pascal、Objective-C、Java、Ada，Go与其他语言。

许多操作系统，包括许多类Unix系统，如Linux及BSD家族都采用GCC作为标准编译器。

GCC原本用C开发，后来因为LLVM、Clang的崛起，它更快地将开发语言转换为C++。许多C的爱好者在对C++一知半解的情况下主观认定C++的性能一定会输给C，但是Ian Lance Taylor给出了不同的意见，并表明C++不但性能不输给C，而且能设计出更好，更容易维护的程序。

GCC是由理查德·马修·斯托曼在1985年开始的。他首先扩增一个旧有的编译器，使它能编译C，这个编译器一开始是以Pastel语言所写的。Pastel是一个不可移植的Pascal语言特殊版，这个编译器也只能编译Pastel语言。为了让自由软件有一个编译器，后来此编译器由斯托曼和Len Tower在1987年以C语言重写并成为GNU项目的编译器。GCC的创建者由自由软件基金会直接管理。

在1997年，一群不满GCC缓慢且封闭的创作环境者，组织了一个名为EGCS（Experimental/Enhanced GNU Compiler System）的项目，此项目汇整了数项实验性的分支进入某个GCC项目的分支中。EGCS比起GCC的建构环境更有活力，且EGCS最终也在1999年四月成为GCC的官方版本。

GCC目前由世界各地不同的数个程序员小组维护。它是移植到最多中央处理器架构以及最多操作系统的编译器。

由于GCC已成为GNU系统的官方编译器（包括GNU/Linux家族），在LLVM、Clang崛起之前，它也是编译与创建其他操作系统的主要编译器，包括BSD家族、Mac OS X、NeXTSTEP与BeOS等。

GCC通常是跨平台软件的编译器首选。有别于一般局限于特定系统与执行环境的编译器，GCC在所有平台上都使用同一个前端处理程序，产生一样的中介码，因此此中介码在各个其他平台上使用GCC编译，有很大的机会可得到正确无误的输出程序。


以2011年10月26日发布的4.6.2版为准，本编译器版本可处理下列语言：

Ada（GNAT）

C（GCC，带 GNU 拓展）

C++（G++，带 GNU 拓展）

Fortran（Fortran 77: G77，Fortran 90: GFORTRAN）

Java（编译器：GCJ；解释器：GIJ）

Objective-C（GOBJC）

Objective-C++

Go

支持的处理器架构

GCC目前支持下列处理器架构（以4.1版为准）：

Alpha

ARM

Atmel AVR

Blackfin

H8/300

IA-32（x86）与x86-64

IA-64 例如：Itanium

MorphoSys家族

Motorola 68000

Motorola 88000

MIPS与龙芯

PA-RISC

PDP-11

PowerPC

System/370，System/390

SuperH

HC12

SPARC

VAX

Renesas R8C／M16C／M32C家族

较不知名的处理器架构也在官方发布版本中支持：

A29K

ARC

C4x

CRIS

D30V

DSP16xx

FR-30

FR-V

Intel i960

IP2000

M32R

68HC11

MCORE

MMIX

MN10200

MN10300

NS32K

ROMP

Stormy16

V850

Xtensa

由FSF个别维护的GCC处理器架构：

D10V

MicroBlaze

PDP-10

MSP430

Z8000

NEC SX-9 并发向量处理机


### 使用方法




gcc 与 g++ 分别是 gnu 的 c & c++ 编译器 gcc/g++ 在执行编译工作的时候，总共需要4步：

1、预处理,生成 .i 的文件[预处理器cpp]

2、将预处理后的文件转换成汇编语言, 生成文件 .s [编译器egcs]

3、有汇编变为目标代码(机器代码)生成 .o 的文件[汇编器as]

4、连接目标代码, 生成可执行程序 [链接器ld]

参数详解

-x language filename

设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。也就是根据约定 C 语言的后缀名称是 .c 的，而 C++ 的后缀名是 .C 或者 .cpp, 如果你很个性，决定你的 C 代码文件的后缀名是 .pig 哈哈，那你就要用这个参数, 这个参数对他后面的文件名都起作用，除非到了下一个参数的使用。 可以使用的参数吗有下面的这些：'c', 'objective-c', 'c-header', 'c++', 'cpp-output', 'assembler', 与 'assembler-with-cpp'。

看到英文，应该可以理解的。

例子用法:

gcc -x c hello.pig 　　
-x none filename

关掉上一个选项，也就是让gcc根据文件名后缀，自动识别文件类型 。

例子用法:

gcc -x c hello.pig -x none hello2.c 　　
-c

只激活预处理,编译,和汇编,也就是他只把程序做成obj文件

例子用法:

gcc -c hello.c 
他将生成 .o 的 obj 文件

-S

只激活预处理和编译，就是指把文件编译成为汇编代码。

例子用法:

gcc -S hello.c 
他将生成 .s 的汇编代码，你可以用文本编辑器察看。

-E

只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面。

例子用法:

gcc -E hello.c > pianoapan.txt 
gcc -E hello.c | more 
慢慢看吧, 一个 hello word 也要与处理成800行的代码。

-o

制定目标名称, 默认的时候, gcc 编译出来的文件是 a.out, 很难听, 如果你和我有同感，改掉它, 哈哈。

例子用法:


gcc -o hello.exe hello.c (哦,windows用习惯了) 
　　gcc -o hello.asm -S hello.c
-pipe


使用管道代替编译中临时文件, 在使用非 gnu 汇编工具的时候, 可能有些问题。


gcc -pipe -o hello.exe hello.c 
-ansi

关闭 gnu c中与 ansi c 不兼容的特性, 激活 ansi c 的专有特性（包括禁止一些 asm inline typeof 关键字, 以及 UNIX,vax 等预处理宏）。
-fno-asm

此选项实现 ansi 选项的功能的一部分，它禁止将 asm, inline 和 typeof 用作关键字。


-fno-strict-prototype

只对 g++ 起作用, 使用这个选项, g++ 将对不带参数的函数,都认为是没有显式的对参数的个数和类型说明,而不是没有参数。

而 gcc 无论是否使用这个参数, 都将对没有带参数的函数, 认为城没有显式说明的类型。


-fthis-is-varialble

就是向传统 c++ 看齐, 可以使用 this 当一般变量使用。


-fcond-mismatch

允许条件表达式的第二和第三参数类型不匹配, 表达式的值将为 void 类型。


-funsigned-char 、-fno-signed-char、-fsigned-char 、-fno-unsigned-char

这四个参数是对 char 类型进行设置, 决定将 char 类型设置成 unsigned char(前两个参数)或者 signed char(后两个参数)。


-include file

包含某个代码,简单来说,就是便以某个文件,需要另一个文件的时候,就可以用它设定,功能就相当于在代码中使用 #include<filename>。

例子用法:


gcc hello.c -include /root/pianopan.h 　　
-imacros file


将 file 文件的宏, 扩展到 gcc/g++ 的输入文件, 宏定义本身并不出现在输入文件中。


-Dmacro

相当于 C 语言中的 #define macro


-Dmacro=defn

相当于 C 语言中的 #define macro=defn


-Umacro

相当于 C 语言中的 #undef macro

-undef


取消对任何非标准宏的定义


-Idir

在你是用 #include "file" 的时候, gcc/g++ 会先在当前目录查找你所制定的头文件, 如果没有找到, 他回到默认的头文件目录找, 如果使用 -I 制定了目录,他会先在你所制定的目录查找, 然后再按常规的顺序去找。

对于 #include<file>, gcc/g++ 会到 -I 制定的目录查找, 查找不到, 然后将到系统的默认的头文件目录查找 。


-I-


就是取消前一个参数的功能, 所以一般在 -Idir 之后使用。


-idirafter dir

在 -I 的目录里面查找失败, 讲到这个目录里面查找。


-iprefix prefix 、-iwithprefix dir

一般一起使用, 当 -I 的目录查找失败, 会到 prefix+dir 下查找


-nostdinc


使编译器不再系统默认的头文件目录里面找头文件, 一般和 -I 联合使用,明确限定头文件的位置。


-nostdin C++


规定不在 g++ 指定的标准路经中搜索, 但仍在其他路径中搜索, 此选项在创 libg++ 库使用 。


-C


在预处理的时候, 不删除注释信息, 一般和-E使用, 有时候分析程序，用这个很方便的。


-M


生成文件关联的信息。包含目标文件所依赖的所有源代码你可以用 gcc -M hello.c 来测试一下，很简单。


-MM


和上面的那个一样，但是它将忽略由 #include<file> 造成的依赖关系。 　　

-MD


和-M相同，但是输出将导入到.d的文件里面 　　

-MMD


和 -MM 相同，但是输出将导入到 .d 的文件里面。


-Wa,option


此选项传递 option 给汇编程序; 如果 option 中间有逗号, 就将 option 分成多个选项, 然 后传递给会汇编程序。


-Wl.option


此选项传递 option 给连接程序; 如果 option 中间有逗号, 就将 option 分成多个选项, 然 后传递给会连接程序。


-llibrary


制定编译的时候使用的库


例子用法


gcc -lcurses hello.c　　
使用 ncurses 库编译程序


-Ldir


制定编译的时候，搜索库的路径。比如你自己的库，可以用它制定目录，不然编译器将只在标准库的目录找。这个dir就是目录的名称。


-O0 、-O1 、-O2 、-O3


编译器的优化选项的 4 个级别，-O0 表示没有优化, -O1 为默认值，-O3 优化级别最高。


-g


只是编译器，在编译的时候，产生调试信息。


-gstabs


此选项以 stabs 格式声称调试信息, 但是不包括 gdb 调试信息。


-gstabs+


此选项以 stabs 格式声称调试信息, 并且包含仅供 gdb 使用的额外调试信息。


-ggdb


此选项将尽可能的生成 gdb 的可以使用的调试信息。

-static


此选项将禁止使用动态库，所以，编译出来的东西，一般都很大，也不需要什么动态连接库，就可以运行。

-share


此选项将尽量使用动态库，所以生成文件比较小，但是需要系统由动态库。

-traditional


试图让编译器支持传统的C语言特性。

GCC 是 GNU 的 C 和 C++ 编译器。实际上，GCC 能够编译三种语言：C、C++ 和 Object C（C 语言的一种面向对象扩展）。利用 gcc 命令可同时编译并连接 C 和 C++ 源程序。



### gcc 命令的常用选项

| 选项         | 解释                                                         |
| :----------- | :----------------------------------------------------------- |
| -ansi        | 只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。 |
| -c           | 只编译并生成目标文件。                                       |
| -DMACRO      | 以字符串"1"定义 MACRO 宏。                                   |
| -DMACRO=DEFN | 以字符串"DEFN"定义 MACRO 宏。                                |
| -E           | 只运行 C 预编译器。                                          |
| -g           | 生成调试信息。GNU 调试器可利用该信息。                       |
| -IDIRECTORY  | 指定额外的头文件搜索路径DIRECTORY。                          |
| -LDIRECTORY  | 指定额外的函数库搜索路径DIRECTORY。                          |
| -lLIBRARY    | 连接时搜索指定的函数库LIBRARY。                              |
| -m486        | 针对 486 进行代码优化。                                      |
| -o FILE      | 生成指定的输出文件。用在生成可执行文件时。                   |
| -O0          | 不进行优化处理。                                             |
| -O 或 -O1    | 优化生成代码。                                               |
| -O2          | 进一步优化。                                                 |
| -O3          | 比 -O2 更进一步优化，包括 inline 函数。                      |
| -shared      | 生成共享目标文件。通常用在建立共享库时。                     |
| -static      | 禁止使用共享连接。                                           |
| -UMACRO      | 取消对 MACRO 宏的定义。                                      |
| -w           | 不生成任何警告信息。                                         |
| -Wall        | 生成所有警告信息。                                           |
